{
    "contents" : "---\ntitle: \"Wprowadzenie do R\"\nauthor: \"A. M. Machno\"\ndate: \"28 września 2015\"\noutput: html_document\n---\n\n##Referencje\n\nR. Peng, R Programming [link](https://leanpub.com/rprogramming)\n\n##Kalkulator\n\nŚrodowisko R można wykorzystac do właściwie dowolnych obliczeń arytmetycznych na liczbach. \nTo co jest wyświetlane w szarej ramce wpisane należy wpisać do konsoli i po wciśnieciu *enter* otrzymamy to co jest w białej ramce (po ##). \n\n```{r}\n1+15\n4/2\n6^3\n625^(.5)\n(1+3)/(2+3^2)\n```\n\n##Funkcje\n\nMożemy korzystać z ogromnej ilości funkcji wbudowanych w R oraz tworzyć własne. Funkcję wywołujemy wpisując jej nazwę oraz argumenty w nawiasie okrągłym.\n\n-pierwiastek:\n```{r}\nsqrt(64)\n```\n\n-funkcja eksponencjalna\n```{r}\nexp(2)\n```\n\nAby dowiedzieć się więcej na temat danej funkcji wpisujemy `?nazwa_funkcji`. Niektóre funkcje mają więcej argumentów, np. funkcja licząca logarytm (`log`) ma dwa argumenty (liczbę, której logarytm chcemy policzy.c oraz podstawę logarytmu). W takiej sytuacji musimy musimy podac dwa argumenty.\n\nliczymy $log_2 (16)$:\n```{r}\nlog(16, 2)\n```\n\nSpoglodając do opisu funkcji `log` możemy dowiedzieć się, że liczba logarytmowana to argument `x`, a podstawa to argument `base`. Wywołując funkcję możemy odwołać się do tych nazw nie pamietając o kolejności argumentów.\n\n```{r}\nlog(x=27, base=3)\nlog(base=3, x=27)\n```\n\nNiektóre agumenty mają wartości domyślne (właściwie to jest bardzo częsty przypadek). W przypadku logarytmu, argument `base` ma wartość domyślną równą *e*. Zatem jeżeli chcemy policzyć logarytm naturalny nie musimy wpisywać podstawy.\n\n```{r}\nlog(2)\nlog(x=12)\n```\n\nJednak jeżeli funkcja nie ma wartości domyślnej do argumentu, nie wpisując wartości otrzymamy błąd. Np. `log(base=5)`.\n\nWiele funkcji nie ma argumentów, lub wszystkie jej argumenty mają wartości domyślne, i tak możemy dowiedzieć się w jakim katalogu pracujemy wpisując `getwd()` lub wyświetlając wszystkie obiekty, które przechowujemy w naszym środowisku `ls()`. \n```{r}\ngetwd()\nls()\n```\n\nJeszcze nie stworzyliśmy ani nie wczytaliśmy nic do naszego środowiska, dlatego wyświetla pustą listę. \n\n##Wektory\n\nPodstawowymi wartościami w R są wektory. Podstawową funkcją, która tworzy wektor jest `c()`.\n\n```{r}\nc(1,3,11,-1,.3)\n```\n\nPracując na wektorach, przeważnie chcemy przypisać jakiejś zmiennej wartości. Stórzmy zatem dwa 5-elementowe wektory `x` i `y`. Do przypisywania wartości służy operator `<-` (lub `->`).\n\n```{r}\nx<-c(2, -1, 3, 1.5, -.5)\ny<-c(1, 2, 3, -1, -5)\n```\n\nTym razem po wpisaniu komend do consoli nie dostaliśmy żadnej odpowiedzi, ale możemy odwołać sie do zmiennych.\n\n```{r}\nx; y\n```\n\nWszystkie podstawowe funkcje liczbowe możemy stosować do wektorów. Działania są wykonywane dla pierwszych elementów wektorów i wartość jest pierwszym elementem wektora wyniku itd. Innymi słowy jest działanie wyraz po wyrazie. \n\n```{r}\nexp(x)\nx+y\nx/y\nx^y\n```\n\nWiele funkcji jako argument (lub kilka argumentów) ma wektor. Podstawowe to np. suma `sum()`, średnia arytmetyczna `mean()`.\n\n```{r}\nsum(x); sum(y)\nmean(x); mean(y)\n```\n\nDzieki temu bardzo szybko możemy policzyć np. wariancję `x`:\n\n```{r}\nmean((x-mean(x))^2); mean((y-mean(y))^2)\nsum((x-mean(x))^2)/length(x); sum((y-mean(y))^2)/length(y)\nsum((x-mean(x))^2)/(length(x)-1); sum((y-mean(y))^2)/(length(y)-1)\n```\n\nOczywiście jest też funckja `var()`, która oblicza wariancję dla wartości z wektora.\n```{r}\nvar(x); var(y)\n```\n\n##Obiekty podstawowe\n\nW R rozróżniamy 6 podstawowych typów obiektów (które przeważnie są elementami wektora): \n\n1. character (napis). Wpisujemy w cudzysłowiu, np. `\"to jest napis\"`.\n2. complex (liczba zespolona). Wpisujemy cześć rzeczywistą plus część urojoną *i*, bez znaku mnożenia, np. `1+2i`.\n3. numeric (liczba rzeczywista). Po prosu wpisujemy liczbę, może byc poprzedzona minusem aby była ujemna, część dziesiętna po **kropce**.\n4. integer (liczba naturalna). Wpisujemy liczbę i *L*, np. `2L`.\n2. factor (zmienna kategoryczna).\n5. logical (wartość logiczna TRUE/FALSE). Wpsujemy `TRUE` lub `FALSE`, przekształcane są w odpowiednio 1 i 0.\n\nRozróżnienie jest ważne, dlatego, że wektory muszą być jednorodne ze względu na obiekty (wszystkie elementy wektora muszą mieć ten sam typ). Typy wypisałem w nieprzypadkowej kolejności, zamiana wektora, który ma wyższy typ bezproblemowo zamienimy na tym niższy, odwrotna operacja przeważnie nie jest możliwa. Jezeli spróbujemy stworzyć wektor niejednorodny, R wybierze obiekt najniższego rzędu w tym wektorze i pozostałe lementy przekształci w ten tym. \n\n```{r}\nmix_vect_1<-c(1L, TRUE, 2+3i)\ntypeof(mix_vect_1); mix_vect_1\n\nmix_vect_2<-c(1,2, 'napis')\ntypeof(mix_vect_2); mix_vect_2\n```\n\nZ punktu widzenia tego kursu najważniejsze są wektory numeryczne i logiczne (okazjonalnie będziemy korzystać z napisów).\n\n##Wartości specjalne\n\nW wyniku niektórych operacji możemy otrzymac nieksończoność `Inf`. Nieskończoność możemy też używać do obliczeń.\n```{r}\n1/0\n.99^Inf\n```\n\nJednak niektórych działań nie da się wykonać i otrzymamy liczbe nioznaczoną.\n\n```{r}\n0/0\n(-1)^.1\n```\n\nJeżeli chcielibysmy przekształcić napis w liczbę, a napis nie będzie liczba otrzymamy również wartość nieoznaczoną:\n\n```{r}\nas.numeric(mix_vect_2)\n```\n\nWidzimy, że dwa pierwsze lementy przekształcono w liczny, a trzeci został zastąpiony przez `NA`. Różnicą między `NaN` i `NA` nie będziemy się zajmować i obie będziemy traktować jak wartości brakujące lub błędne w zalezności od kontekstu.\n\n##Atrybuty\n\nWiele obiektów w R posiada atrybuty, w szczególności wektory. Przykładowe atrybuty to:\n\n- names, dimnames (nazwa, nazwa wymiarów dla macierzy i innych wielowymiarowych obiektów).\n- dim (wymiar).\n- class (klasa).\n- length (długość).\n\nWszystkie atrybuty danego obiektu możemy uzyskać dzięki funkcji `attributes()`.\n\nPrzypiszemy nazwy wartościom w wektorze `mix_vect_1`, odpowiadjące jego klasie.\n\n```{r}\nnames(mix_vect_1)\nnames(mix_vect_1)<-c('integer', 'logical', 'complex')\nnames(mix_vect_1)\nmix_vect_1\n```\n\n##Podzbiory\n\nAby otrzymać konkretną współrzędna wektora odwołujemy sie do niego w nawiasie kwadratowym. Trzeci element wektora *x* to:\n\n```{r}\nx[3]\n```\n\nAby otrzymać wektor, składający się z wektora *x* bez jego trzeciego elementu poprzedzamy to znakiem minus:\n\n```{r}\nx[-3]\n```\n\nMożemy odwołać się do wektora, składającego się z trzeciego i piątego elementu *x*:\n\n```{r}\nx[c(3,5)]\n```\n\n**Ważne**: odwołanie jest wektorem a nie ciągiem liczb!\n\n##Operatory i warunkowanie logiczne\n\nPodstawowe operatory logiczne to koninkcja `&`, alternatywa `|` i negacja `!`. W zastosowaniach najczęstsze waunki, które nas interesują to czy zachodzi równość `==`, nierówność `!=`, mniejszość `<`, niewiększość `<=`, większość `>` i niemniejszość `>=`.\n\nSprawdźmy czy 2 jest większe od 3:\n\n```{r}\n2>3\n```\n\nMożemy w jednej komendzie sprawdzić, które elementy *x* są ujemne:\n\n```{r}\nx<0\n```\n\nlub, które lementy *x* są niemnijesze niż odpowiednie elementy *y*:\n\n```{r}\nx>=y\n```\n\nDzięki wektorom logicznym, możemy otrzymać wszystkie dodatnie wartości z wektora *y*:\n\n```{r}\ny[y>0]\n```\n\nSzczególnie wygodne i użyteczne jest używanie warunków logicznych do konstrukcji podzbiorów. Jakie wartości przyjmuje *x* jeżeli y jest dodatni?\n\n```{r}\nx[y>0]\n```\n\n##Statystyka Opisowa\n\nPrzykładowe statystyki opisowe, dla których są funkcje w podstawowym pakiecie R to:\n\n- średnia `mean()`\n- mediana `median()`\n- odchylenie standardowe `sd()`\n- odchylenie średnie `aad()`\n- kwantyl (w szczególności kwartyle) `quantile`\n\nPrzykładowe statystyki opisowe, dla których nie ma funkcji w podstawowym pakiecie R to:\n\n- dominanta\n- skośność\n- kurtoza\n\n\n##Przykłady\n\nWczyutajmy dane `mtcars`, które są dostępny w podstawowym pakiecie R.\n\n```{r}\ndata(mtcars)\nstr(mtcars)\n```\n\nJest to ramka danych (*data.frame*) składająca się z 32 obserwacji i 11 wartości dla każdej z nich. Są to dane techniczne 32 modeli samochodów.\n\nRamke danych możemy traktować jak dwuwymiarową tablicę i odwoływać się do elementów przez nawias kwadratowy. Gdzie na pierwszej współrzędnej podajemy które wiersze mają być wyswietlone, a na drugiej, które kolumny. Po pozostawieniu pustego wymiaru, wszystkie lementy zostana wyswietlone.\n\n```{r}\nmtcars[1,c(1,2)]\nmtcars[,3]\n```\n\nMożemy odwołać sie do zmiennej w danych przez jej nazwę iznak dolara:\n\n```{r}\n#liczba cylindrów w kolejnych samochodach\nmtcars$cyl\n```\n\nPoliczmy średnią masę samochodów z bazy `mtcars`\n\n```{r}\nmean(mtcars$wt)\n```\n\nPoliczmy teraz średnią masę dla samochodów z 8 cylindrami:\n\n```{r}\n#dla jasności wprowadzamy nowe wektory odpowiadające wadze i ilości cylindrów\nweight<-mtcars$wt\ncylinders<-mtcars$cyl\nmean(weight[cylinders==8])\n```\n\nNa histogramie objętości silników, widzimy, że dane są lekko niesymetryczne:\n\n```{r}\nhist(mtcars$disp, main=\"Histogram\", col=2, xlab=\"objetość (cale sześcienne)\", ylab=\"ilość\")\nabline(v=mean(mtcars$disp), lw=3)\n```\n\nPoliczmy zatem skośność:\n\n```{r}\n#dla wygody tworzymy nową zmienną\ndisp<-mtcars$disp\n\n#liczmy średnią\ndisp.mean<-mean(disp)\n\n#i odchylenia od średniej\ndisp.dev<-disp-disp.mean\n\n#trzecia potęga odchyleń i srednia\ndisp.dev.3<-disp.dev^3\n\n#to jest trzeci moment centralny\ndisp.dev.3.mean<-mean(disp.dev.3)\n\n#skośność\n  disp.dev.3.mean/sd(disp)^3\n```",
    "created" : 1443439234820.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "501675200",
    "id" : "50DE8D86",
    "lastKnownWriteTime" : 1444559370,
    "path" : "C:/Users/Artur/Dropbox/AGH/dydaktyka/statystyka ZiP/2015-2016/R/R_intro.Rmd",
    "project_path" : "R_intro.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}