{
    "contents" : "---\ntitle: \"Funkcje-pętle w R\"\nauthor: \"A. M. Machno\"\ndate: \"12 października 2015\"\noutput: html_document\n---\n\n\n##apply     \n\nCzęsto zdaża się, że chcemy wykonać jakąś operację dla każdej z kolumn lub wierszy macierzy (lub ramki danych, tablicy). Dzięki funkcji `apply` możemy takie operacje wykonać w bardzo szybki sposób. \n\nWygenerujmy sobie na początek macierz *40x5* składających się z realizacji rozkładu Poissona o średniej $\\lambda =1$. I policzmy średnią oraz medianę dla każdej kolumny, oraz dla każdego wiersza.\n\n```{r}\n#wektor 200 elementowy z rozkładu normalnego\nx<-rnorm(40*5)\n\n#przekształcamy na macierz\ndim(x)<-c(40,5)\n\n#liczymy średnie w wierszach\nr.mean.x<-apply(x, 1, mean)\n#mediany w wierszach\nr.median.x<-apply(x, 1, median)\n\n#Średnie w kolumnach\nc.mean.x<-apply(x, 2, mean)\n#mediany w kolumnach\nc.median.x<-apply(x, 2, median)\n```\n\nGdybyśmy chcieli użyć funkcji, w której wyniku otrzymujemy wektor dla każdej kolumny (wiersza), wyniki zostaną przedstawione w postaci macierzy. Dodatkowo, jeżeli w użytej funkcji wewnątrz `apply` istnieją dodatkowe argumenty, możemy się do nich odnieść przez ich nazwę wewnątrz wywołania `apply`.\n\nPoliczmy rozrzut (minimum i maksimum) w każdej z kolumn `x`. Funkcja `quantile` dla argumentu `probs=0` wylicza minimum, ale dla `probs=1` maksimum (alternatywa dla funkcji `max` i `min`).\n\n```{r}\napply(x, 2, quantile, probs=c(0,1))\n```\n\n##lapply i sapply\n\nJeżeli mamy listę i chcemy wykonać tę samą funkcję dla każdego z elementów listy, używamy funkjci `lapply`. Załóżmy, że mamy listę składającą się z wielu zestawów danych i chcemy wyświetlić wymiary każdego ze zbiorów.\n\n```{r}\n#wczytujemy dane wbudowane w R\ndata(iris)\ndata(mtcars)\ndata(InsectSprays)\n\n#tworzymy listę składającaą się z tych danych\ndata.list<- list(flowers=iris, cars=mtcars, sprays=InsectSprays)\n\n#wyświetlamy wymiary każdego ze zbiorów\nlapply(data.list, dim)\n```\n\nWynikiem działania `lapply` jest lista, która ma tyle samo elementów co lista, która jest argumentem funkcji i elementy mają te same nazwy. Elementami w liście są wyniki funkcji dla każdego z elementów wyjściowej listy.\nCzęsto wygodniejsze jest dla nas, aby wyniki były przedstawione w formie wektora (lub macierzy), szczególnie jeżeli wynikiem dziłania funkcji dla każdego elementu jest liczba lub wektor. W takich przypadkach używamy uproszczonej wersji `lapply`, czyli `sapply`.\n\n```{r}\nsapply(data.list, dim)\n```\n\n##tapply\n\nJeżeli chcemy zadziałać funkcją na wektorze (liście), ale warunkowo to używamy funkcji `tapply`. Jeżeli chcemy abliczyć kwartyle zmiennej `mpg` w zbiorze `mtcars`, ale dla każdego poziomu zmiennej `am` osobno. Tzn. chcemy policzyc kwartyle `mpg` (ilości mil na galonie) w zalezności, czy jest to samochód ze skrzynią automatyczną czy manualną.\n\n```{r}\nq.mpg<-tapply(mtcars$mpg, mtcars$am, quantile, probs=c(.25, .5, .75))\nq.mpg\n```\n\n##split\n\nAby wykonać operacje analogiczne do `tapply`, ale nie dla wektorów, tylko dla ramek danych, korzystamy najpierw z funkcji `split`. Funkcja `split` dzieli nam dane ze względu na wartość jakiejś zmiennej kategorycznej. \n\nGdybyśmy chcieli podzielić dane `mtcars` ze względu na wartość zmiennej `cyl`.\n\n```{r}\ncars.by.cyl<-split(mtcars, mtcars$cyl)\ncars.by.cyl\n```\n\nW wyniku otrzymujemy listę, w której każy element jest ramką danych, o tej samej strukturze co wyjściowa ramka, ale składa się tylko z elementów, gdzie wartość `mtcars$cyl` jest wspólna.\n\nBardzo często korzystamy ze `split` wraz z `lapply` (lub `sapply`). \n\n",
    "created" : 1444653208071.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1393167282",
    "id" : "B134A82A",
    "lastKnownWriteTime" : 1444661915,
    "path" : "C:/Users/Artur/Dropbox/AGH/dydaktyka/statystyka ZiP/2015-2016/R/R_loopFunctions.Rmd",
    "project_path" : "R_loopFunctions.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_markdown"
}